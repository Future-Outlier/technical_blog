1. High Availability 是掛了趕緊治好
2. High Reliability 是不要掛掉
3. deployment 跑 stateless application
4. stateful set 跑 stateful application
5. fault tolerance 是達成 high availability 的手段
    通常有以下手段：
    - 重試
    - checkpoint: 把狀態存起來，如果掛了可以從 checkpoint 恢復
    - replication: 複製多份，如果掛了可以從其他份恢復
    - failover: 從掛掉的 a 移動到 啟動的 b 的行為
    - Fallback: 替代方案
6. 解釋 raycluster, rayservice, rayjob controller lifecycle
    發現有點複雜，跳過
7. worker group 是 ray 的概念，就是表達一種 node type, 表示這種 node 特定資源
    usecase: training
8. startup probe,readiness probe, liveness probe
    startup probe: 開機了嗎？
    readiness probe: 準備好了嗎？ -> 活著，不一定準備好
    liveness probe: 活著嗎？ -> 不一定活著
9. ray 有哪些 metrics? kuberay 有什麼 metrics?
    a. 用到再查就好
    b. controller metrics 已經查得到了
10. ray 如何實現 fault tolerance?
    1. 分成兩個 level, application level 和 system level
        1. application level: User code bugs
        2. system level: Node failures, Network failures, Ray 內部 bug
11. k8s 有至少兩種資源限制方式, cgroup 和 resource quota
    1. cgroup: 限制 Container/Pod 的資源使用
    2. resource quota: 限制 namespace 的資源使用
12. Multi-tenant 的好處是大家共享 infra strucutre, 但又互不干擾
13. 1 個 RayCluster CR 如果只有 1 head pod, 1 worker pod, 大約 7 KB, 所以離 hit etcd limit 8gb 還有一段距離就是了
14. CAP: 一致性、可用性、網路分區
    系統永遠只有 CP or AP, 因為網路一定會出事
    to learn: ray, k8s, slurm, spark, flink, hadoop ＣＡＰ比較、架構比較
15. ray 啟動 raycluster 以及跑任務的 lifecycle? 每個 component 做了什麼？
    1. Task: stateless task, 分散式 worker 執行
    2. Actor: stateful service, 有狀態
    3. 存在分散式 Object Store 中，用 ObjectRef 來引用
    4. placement group: gang scheduling 幫你準備資源
    5. head node: worker + gcs + api server + driver
    6. worker node: worker
    7. GCS: head node 的 metadata service
    8. Raylet: ray 的 kubelet, 但是包含本地 scheduler, 且 node 跟 node 之間可以通信
    9. Ray Agent:收集本地 metrics 和安裝 runtime environments
    10. Dashboard: only head node
    11. Driver: 運行主角本的進程
```
┌─────────────────────────────────────────────────────────────────┐
│                         Ray Cluster                             │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────┐│
│  │                      Head Node                              ││
│  │  ┌───────────┐  ┌──────────────┐  ┌────────────┐           ││
│  │  │    GCS    │  │  Autoscaler  │  │  Dashboard │           ││
│  │  │ (元資料)   │  │  (自動擴展)   │  │  (Web UI)  │           ││
│  │  └───────────┘  └──────────────┘  └────────────┘           ││
│  │  ┌───────────┐  ┌──────────────┐  ┌────────────┐           ││
│  │  │  Raylet   │  │ Object Store │  │ Ray Agent  │           ││
│  │  │ (本地調度) │  │ (物件存儲)    │  │ (監控/env) │           ││
│  │  └───────────┘  └──────────────┘  └────────────┘           ││
│  │  ┌────────────────────────────────────────────┐            ││
│  │  │  Workers (執行 Tasks / Actors)              │            ││
│  │  └────────────────────────────────────────────┘            ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │                    Worker Node(s)                           ││
│  │  ┌───────────┐  ┌──────────────┐  ┌────────────┐           ││
│  │  │  Raylet   │  │ Object Store │  │ Ray Agent  │           ││
│  │  └───────────┘  └──────────────┘  └────────────┘           ││
│  │  ┌────────────────────────────────────────────┐            ││
│  │  │  Workers (執行 Tasks / Actors)              │            ││
│  │  └────────────────────────────────────────────┘            ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```

16. ray lifecycle
太複雜了，下次研究
17. service discovery?
    a. DNS 是其中一種方式
    b. pod IP 很容易一直變
    c. 在動態環境中，服務 A 如何找到服務 B？, 就是通訊錄
18. HEAD CPU:0 代表不 scheudle task 到 head 上，減少其他 component 壓力


not yet solved:

7. CAP, ray, k8s, slurm, 等等，到底是側重哪個？怎麼建立幾的判斷系統
8. anyscale platform??? 真的有用 k8s 嗎？還是只有 VM
    leader election
    MVCC
    
    etcd, spanner, dist
    
    https://www.andrew.cmu.edu/course/15-440/
    
    [https://cloud.google.com/blog/products/containers-kubernetes/gke-65k-nodes-and-counting#:~:text=This achievement is made possible by a,distributed database that delivers virtually unlimited scale](https://cloud.google.com/blog/products/containers-kubernetes/gke-65k-nodes-and-counting#:~:text=This%20achievement%20is%20made%20possible%20by%20a,distributed%20database%20that%20delivers%20virtually%20unlimited%20scale).
    